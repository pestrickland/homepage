Tags: Third party risk, Python
Date: 2012-05-12 20:07:00
updated: 2012-06-23 16:03:00
Title: Introducing Impact
Slug: third-party-risk-3
Summary: As part of my personal project studying the calculation of third party risk associated with airborne weapons, I have been writing a Monte Carlo simulation program to study hit probabilities. I have reached a stable version of the code that is very basic and generates uniform distributions of people, towns and weapon hits. This article describes the functionality of the program and the plan for future development.
status: draft

In my previous articles, I have written about the [third party risk associated with weapon releases]({filename}001_third-party-intro.markdown "third-party-risk-1")
and
[how it can be calculated]({filename}004_basics-of-third-party-risk.markdown "third-party-risk-2").
Using the assumptions I made in order to simplify the problem, I have spent the
last few months developing a program that uses Monte Carlo simulation to
calculate hit probabilities for weapon failures. The unimaginative name of the
program I came up with is *Impact*. Although the primary goal of
the project is to study whether more complex population modelling could offer
improved risk calculations, it is also an opportunity for me to develop my
programming ability.

In this article, I will provide an outline of the stable version of my program, how I have developed
it to date and the plans I have for the future.

##Program basics
The basic functionality of the program so far is described below. It is
written in Python; I chose this language because it seemed to be the most
accessible both to learn and to actually start writing code.

My development process to date has been based on getting something working, and
then trying to improve the code. As I will discuss here, I plan to create a set
of modules that allow different types of assessment to be carried out. It is
therefore important that my code is as reusable as possible and that each
module, class or method does a specific task and is not duplicated wherever
possible.

The sections below describe the major steps in the program.

### Specify simulation parameters
A number of parameters are required to define the model. These should be
entered by the user in one of several ways, but the program reverts to default
values in the event that some parameters are missing.

 * Number of iterations
 * Size of impact area
 * Baseline population density
 * Number of towns, and size and population density of each town
 * Lethal radius of weapon

The number of iterations equates to the number of weapon impact points
generated. The population model remains unchanged for each iteration. I have
also included basic functionality for generating multiple population models,
which effectively just repeats the program for each model.

The impact area is generated by specifying a radius. This assumes that a weapon
has a finite amount of energy, and therefore the radius around its release
point is as far as it can possibly fly before hitting the ground. The model
itself, however, currently takes this radius and uses it as the side of a
square.

The baseline population density is used to generate the general population
density for the entire area. If towns are specified, these are superimposed onto
the baseline population. For each town, its size is specified as a radius, but
results in a square in the same way as the model size is defined.

The lethal radius of the weapon defines the area within which any person will be
considered "hit". For explosive weapons, I will use a nominal value in the
absence of any sensitive data. It is worth noting too that non-explosive
impacts can also be studied. For instance, some weapons eject debris as part of
their launch sequence, and there are also events such as external fuel tank
jettison that may be of interest.

If the lethal radius is reduced to produce an area that represents a standing
person, the program would only calculate direct hits -- i.e. when the object
enters the physical space occupied by the person.

<figure>
<a href="/images/direct_hit_big.png">
<img src="/images/direct_hit.png" title="Illustration of direct hit definition">
</a>
<figcaption>
By sizing the lethal area to be equivalent to that of a standing person, the
effect of a non-explosive projectile can be modelled. A hit will only be
recorded if the projectile hits within the blue area.
</figcaption>
</figure>

### Generate population model
The major development of the program began with the generation of the
population model, and around it the rest of the program was built. It is also
one of the more computationally expensive parts of the code. It functions as
follows.

 * For each member of the baseline population, generate x and y coordinates
 * For each town, generate x and y coordinates
 * For every member of each town's population, generate x and y coordinates
   within the town's radius

The use of random numbers is one of the key features of Monte Carlo
simulations. For my program, the locations of the population, towns and weapon
impacts are all randomly generated. To do this I use the
[NumPy](http://numpy.scipy.org "NumPy") package. Currently I make the assumption
that there is a uniform distribution of people and I therefore use the
[`numpy.random.uniform()`](http://docs.scipy.org/doc/numpy/reference/generated/numpy.random.uniform.html#numpy.random.uniform)
function. This function is used to draw random samples from the interval formed
by the model range:

    :::python3
    x = numpy.random.uniform(-1 * model_range, model_range)
    y = numpy.random.uniform(-1 * model_range, model_range)

Coordinates for town centres are generated in the same way. Members of town
populations are also created in a similar way, but with samples drawn from the
interval formed by the town's size rather than that of the model. A further step
is that the "local" coordinates of people in towns need to be converted into the
"global" model coordinates. This is achieved by simply adding the town
coordinates to the local coordinates of each person:

    :::python3
    for dummy in range(town_population):
        # Generate location at random within town_radius.
        person_x = numpy.random.uniform(-1 * town_radius, town_radius)
        person_y = numpy.random.uniform(-1 * town_radius, town_radius)
        # Convert coordinates for an urban person from local to global,
        # i.e. add the coordinates of the town centre to the person's.
        person_x += town_x
        person_y += town_y

### Run iterations
With a population model in place, the requested number of iterations are
performed by generating a random weapon impact point. The impact point is
generated in the same way as towns and people discussed above.

 * Generate x and y coordinates for weapon impact, within impact area
 * For each member of the total population, calculate distance between person
   and impact location
 * If distance is *less* than lethal radius, count as a hit

In order to calculate the range from each person to the impact point, a small
amount of Pythagoras is used.

$$
\mathrm{range}^2 =
  \left(x_\mathrm{weapon} - x_\mathrm{person}\right)^2
+ \left(y_\mathrm{weapon} - y_\mathrm{person}\right)^2
$$

If the squared range value for a person is less than the squared lethal radius,
then that person is inside the lethal area for the weapon, and a hit is
recorded for that iteration.

### Calculate hit probability
Based on the number of iterations processed, the probability of a hit is a
simple ratio. For each iteration, only one hit is required -- any further hits
have no effect on the probability. If 100 iterations are run, and 23 of those
have at least one hit, then the probability calculated is 23%.

The greater the number of iterations, the more accurate the resultant
probability should be. When a particular scenario has a very low hit rate,
more iterations are required just to generate a probability greater than zero.
For instance, if I only run 100 iterations on a scenario with a probability of
1.0E-04 (1 in 10000), my results will tend to be either zero or 1.0E-02 (1 in
100), obscuring the true probability. I have yet to determine how many
iterations are required as a minimum to produce a confident result, but that is
one element I plan to research. In the absence of any better information, I have
typically been running 10000 iterations at a time, increasing the iterations as
the number of hits reduces.

##Modules
Once I got a working version of the program, I looked at how I could improve it
by making it modular. The first stable version includes the following modules:

 * `model.py`
 * `run.py`
 * `interface.py`
 * `plot.py`
 * `tests.py`

The classes and methods for  generating population models, locating weapon
impacts and determining whether a hit occurs are all contained in `model.py`.
The program is run in `run.py`. User inputs are processed, instances of the
classes in `model.py` are created and the iterations occur there too. Validation
of user inputs and configuration file parameters occur in `interface.py`. There
is also a basic interactive mode available that asks the user to specify the
model parameters one by one. Finally, `plot.py` contains some very basic
plotting capability using
[matplotlib](http://matplotlib.sourceforge.net/ "matplotlib"),
and `tests.py` is where I have begun writing tests, primarily of the model.

For the next phase of development, I considered the process through which the
program might be used as it becomes more advanced. It occurred to me to think
in terms of pre-processing, processing and post-processing.

<figure>
<a href="/images/program_flow_big.png">
<img src="/images/program_flow.png" title="Basic program flow">
</a>
<figcaption>
Future development of the program should allow more modules to be
created and used as required.
</figcaption>
</figure>

The pre-processing activities consist of setting up the population model.
Although currently that simply involves uniformly scattering a population over
an area and then adding concentrations that represent towns, in the future
this could be more complex. Briefly, other parameters that might be specified
include:

 * Time of day
 * Presence of buildings or other obstructions
 * Specific geographic location

The processing part of the program is where the simulation is repeatedly run.
For the time being, I will have simple random weapon impacts, but it might be
possible to shape the distribution depending on known weapon behaviour. As a
simple example, a forward firing missile is very unlikely to be able to reach
all points within a circle around its release point -- a lot of energy would be
lost in turning through 180&deg; meaning that a smaller area of hits would
exist behind the release point. The key Monte Carlo requirement for randomness
would need to be maintained, and I would expect that this could be
accomplished by applying random values to various coefficients that dictate the
weapon behaviour at launch.

Initially I designed the lethal radius to be random as well. The idea behind
this is that blast and fragmentation patterns are highly dependent on
conditions at detonation. Therefore different impact angles, and detonations
that occur above, on and under the ground all affect the lethal radius. For
simplicity at the moment, the area is fixed, but that is certainly another area
that could be developed further.

Post-processing consists of acting on the raw hit probabilities generated during
the processing stage. This could involve plotting the model for every iteration
with a hit recorded, performing statistical analysis or simply writing an
output file. Advanced usage could involve using additional data to mitigate the
risk to people associated with the hit probability. For example, if the area
being studied is known to be populated by people outside during the day, but at
night 80% of the population will be indoors, knowledge of the protection
offered by buildings could be applied.

I have broken the development branch of my code into four packages, each of
which could contain specific modules as further development takes place. The
packages are:

 * `interface` -- user input, validation and future GUI
 * `popkill` -- post-processing hit information to apply mitigating effects
   such as building protection
 * `population` -- model generation
 * `results` -- production of graphs, statistical analysis and generation of
   output files

##Future development
Future development of this program can be broadly broken down into two
elements:

 1. Development of functionality
 2. Code improvement

The development of the program's functionality has been discussed at various
points in this article. To be honest, I have a very loosely defined set of
requirements for the program, as it is a hobby of mine rather than something
being developed with a specific user in mind. However, as I learn more, both by
researching the Monte Carlo method, programming and population modelling, and
also by studying results from the program itself, each feature I choose to
develop will hopefully begin to shape the program into a useful set of tools
that could be used in the management of risk.

The code I have written to date is fairly basic and I expect it is quite
inefficient. Not being experienced in writing code, it has taken a long time
both to learn what is needed, and also to debug where I have gone wrong.
However, I do have a functional -- albeit basic -- program. The code is fairly
well commented and I have written a few tests that should help with further
development. The code also resides in a
[Bazaar](http://bazaar.canonical.com/en/ "Bazaar")
repository to allow version control. What is needed for the future is an
increase in efficiency (for instance by using
[NumPy arrays](http://www.scipy.org/Tentative_NumPy_Tutorial#head-6a1bc005bd80e1b19f812e1e64e0d25d50f99fe2
"NumPy Basics") instead of native lists), improved error handling and the
construction of a robust API that allows the program to be as modular as
possible. I also envisage a GUI being used at some point, but that is far in the
future at the moment.

##Summary
In the last few months I have been writing a simple Monte Carlo simulation
program to study hit probabilities. I currently have a stable version of the
code, which simply generates uniformly random distributions of coordinates.
These coordinates are used to locate people, towns and weapon impact points.

For each generated population model, a number of iterations are performed. For
each iteration, a random impact point is generated, and a calculation is
performed to determine if any people are considered to be hit. The number of
iterations registering at least one hit divided by the total number of
iterations performed produces the hit probability associated with that
particular population model, generated by the set of parameters used for the
simulation.

The next stages of development aim to:

 * Enhance the capability of the program
 * Increase the efficiency of the code
 * Apply best coding practice where possible

I am not expecting to get anywhere fast with this project -- the last few
months have shown that there is much for me to learn, and it all takes time.
However, I have still learned a lot, and have a fairly good idea of where I
think I can get to in the future.
